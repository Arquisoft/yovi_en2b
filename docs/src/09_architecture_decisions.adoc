ifndef::imagesdir[:imagesdir: ../images]

[[section-design-decisions]]
== Architecture Decisions
:icons: font

ifdef::arc42help[]
[role="arc42help"]
****
.Contents
Important, expensive, large scale or risky architecture decisions including rationales.
With "decisions" we mean selecting one alternative based on given criteria.

Please use your judgement to decide whether an architectural decision should be documented
here in this central section or whether you better document it locally
(e.g. within the white box template of one building block).

Avoid redundancy. 
Refer to section 4, where you already captured the most important decisions of your architecture.

.Motivation
Stakeholders of your system should be able to comprehend and retrace your decisions.

.Form
Various options:

* ADR (https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions[Documenting Architecture Decisions]) for every important decision
* List or table, ordered by importance and consequences or:
* more detailed in form of separate sections per decision

.Further Information

See https://docs.arc42.org/section-9/[Architecture Decisions] in the arc42 documentation.
There you will find links and examples about ADR.

****
endif::arc42help[]

=== ADR-001: BFF + internal services (REST)

Context::
- Browser-facing API must be centralized.
- We have webapp (frontend + backend), users, and gamey.

Decision::
- Use webapp-backend as Backend-for-Frontend (BFF).
- webapp-backend communicates with users and gamey via REST.

Consequences::
- Frontend only talks to BFF; internal services are not directly called from the browser.
- BFF centralizes orchestration and security checks.

IMPORTANT: Status: PROPOSED 

=== ADR-002: Internal endpoints between BFF and gamey

Context::
- gamey is internal and provides core game logic.
- BFF must check availability and request bot move selection.

Decision::
- gamey exposes (internal) endpoints:
  - GET /Status (health check)
  - POST /{api_version}/ybot/choose/{bot_id} (accepts YEN/JSON game state, returns coordinates as JSON)

Consequences::
- Internal API is small and focused.
- Requires stable request/response contracts for YEN and move coordinates.

IMPORTANT: Status: PROPOSED 

=== ADR-003: YEN/JSON as game state contract + validation in gamey

Context::
- Game state must follow YEN notation.
- Invalid game states must be rejected.

Decision::
- Exchange game state as JSON following YEN.
- Validate YEN in gamey; return JSON error response when invalid.

Consequences::
- Single point of truth for domain validation is gamey.
- BFF treats validation errors as 4xx and surfaces them to clients.

IMPORTANT: Status: PROPOSED 

=== ADR-004: Stateless engine + no game state persistence in M1

Context::
- M1 prioritizes end-to-end functionality.
- Persisting game states is out of scope for M1.

Decision::
- gamey is stateless.
- No persistence of game state in M1.

Consequences::
- Each request must carry all required state.
- Simplifies deployment and testing for M1.

IMPORTANT: Status: PROPOSED 

=== ADR-005: API versioning

Context::
- Breaking changes may happen; backward compatibility is not strict.

Decision::
- Breaking changes require a major version bump (v1.x -> v2).
- M1 ships API v1 only.

Consequences::
- Clear rule for future evolution.

IMPORTANT: Status: PROPOSED 

=== ADR-006: JWT signing algorithm for M1

Context::
- users issues tokens; webapp-backend validates them.
- We want minimal implementation complexity in M1.

Decision::
- Use HS256 for JWT signing/verification in M1.

Consequences::
- Simpler setup (shared secret).
- The verification component (webapp-backend) also needs the shared secret, increasing impact if it leaks (trade-off accepted).

IMPORTANT: Status: PROPOSED 

=== ADR-007: Secrets/config injection mechanism

Context::
- Secrets must not be stored in git.
- We need a simple approach for local dev and CI.

Decision::
- Use environment variables for secrets/config.
- In local dev, load them via dotenv (.env not committed).

Consequences::
- Easy to use with Docker Compose and CI secret stores.
- Requires discipline to avoid printing/leaking env values in logs.

IMPORTANT: Status: PROPOSED 

=== ADR-008: Error response envelope

Context::
- Multiple services and clients need consistent error handling.

Decision::
- Standardize JSON error responses using:
  - errorCode
  - message
  - requestId

Consequences::
- Easier frontend/BFF error mapping and debugging.
- Requires keeping error codes stable over time.

IMPORTANT: Status: PROPOSED 

=== ADR-009: Timeouts and retries for BFF -> gamey

Context::
- The choose endpoint is idempotent, so it can be retried safely. [web:162]
- The bot algorithm may be slow, but long waits hurt gameplay.

Decision::
- For POST /api/v1/ybot/choose/{bot_id}:
  - timeout: 10 seconds
  - retry: 1 retry (policy may change)
- For GET /Status:
  - polled every 2 seconds while waiting for choose (implementation detail may change)

Consequences::
- Prevents "hanging" requests and keeps the game responsive.
- Retries increase load and latency; keep them strictly bounded. [web:183]

IMPORTANT: Status: PROPOSED 

=== ADR-010: User persistence and minimal user entity

Context::
- users should persist users in a database.
- We likely need credentials, not only usernames.

Decision::
- users will persist user accounts.
- Minimal entity includes credentials (exact schema TBD, e.g., username + password hash + id).

Consequences::
- Requires choosing DB technology and defining credential storage rules (hashing, etc.).
- Enables real authentication flows.

IMPORTANT: Status: PROPOSED 

=== ADR-011: Public entrypoint and routing

Context::
- We want a single public entry point.
- Frontend must be served from the root path.
- Backend API must be versioned under a stable prefix.

Decision::
- Public routes:
  - / -> frontend (static assets / SPA)
  - /api/v1/... -> webapp-backend (BFF API)

Consequences::
- Clear separation between UI and API.
- Enables a reverse proxy setup with path-based routing.

IMPORTANT: Status: PROPOSED 

=== ADR-012: Reverse proxy for path-based routing (Nginx)

Context::
- We need to route / to the frontend and /api/v1/... to the BFF behind a single port.
- An API gateway is considered overkill for this project.

Decision::
- Use an Nginx reverse proxy for path-based routing.

Consequences::
- One public port with simple routing rules (e.g., `location` + `proxy_pass`). [web:187]
- Adds an extra component to configure and maintain (but still lightweight).

IMPORTANT: Status: PROPOSED 