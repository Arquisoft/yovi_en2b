ifndef::imagesdir[:imagesdir: ../images]

[[section-design-decisions]]
== Architecture Decisions

ifdef::arc42help[]
[role="arc42help"]
****
.Contents
Important, expensive, large scale or risky architecture decisions including rationales.
With "decisions" we mean selecting one alternative based on given criteria.

Please use your judgement to decide whether an architectural decision should be documented
here in this central section or whether you better document it locally
(e.g. within the white box template of one building block).

Avoid redundancy. 
Refer to section 4, where you already captured the most important decisions of your architecture.

.Motivation
Stakeholders of your system should be able to comprehend and retrace your decisions.

.Form
Various options:

* ADR (https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions[Documenting Architecture Decisions]) for every important decision
* List or table, ordered by importance and consequences or:
* more detailed in form of separate sections per decision

.Further Information

See https://docs.arc42.org/section-9/[Architecture Decisions] in the arc42 documentation.
There you will find links and examples about ADR.

****
endif::arc42help[]

=== ADR-001: BFF + internal services (REST)

Context::
- Browser-facing API must be centralized.
- We have webapp (frontend + backend), users, and gamey.

Decision::
- Use webapp-backend as Backend-for-Frontend (BFF).
- webapp-backend communicates with users and gamey via REST.

Consequences::
- Frontend only talks to BFF; internal services are not directly called from the browser.
- BFF centralizes orchestration and security checks.

IMPORTANT: Status: PROPOSED 

=== ADR-002: Internal endpoints between BFF and gamey

Context::
- gamey is internal and provides core game logic.
- BFF must check availability and request bot move selection.

Decision::
- gamey exposes (internal) endpoints:
  - GET /Status (health check)
  - POST /{api_version}/ybot/choose/{bot_id} (accepts YEN/JSON game state, returns coordinates as JSON)

Consequences::
- Internal API is small and focused.
- Requires stable request/response contracts for YEN and move coordinates.

IMPORTANT: Status: PROPOSED 

=== ADR-003: YEN/JSON as game state contract + validation in gamey

Context::
- Game state must follow YEN notation.
- Invalid game states must be rejected.

Decision::
- Exchange game state as JSON following YEN.
- Validate YEN in gamey; return JSON error response when invalid.

Consequences::
- Single point of truth for domain validation is gamey.
- BFF treats validation errors as 4xx and surfaces them to clients.

IMPORTANT: Status: PROPOSED 

=== ADR-004: Stateless engine + no game state persistence in M1

Context::
- M1 prioritizes end-to-end functionality.
- Persisting game states is out of scope for M1.

Decision::
- gamey is stateless.
- No persistence of game state in M1.

Consequences::
- Each request must carry all required state.
- Simplifies deployment and testing for M1.

IMPORTANT: Status: PROPOSED 

=== ADR-005: API versioning

Context::
- Breaking changes may happen; backward compatibility is not strict.

Decision::
- Breaking changes require a major version bump (v1.x -> v2).
- M1 ships API v1 only.

Consequences::
- Clear rule for future evolution.

IMPORTANT: Status: PROPOSED 

=== ADR-006: JWT signing algorithm

Context::
- users issues tokens; webapp-backend validates them.
- We want minimal implementation complexity.

Decision::
- Use HS256 for JWT signing/verification.

Consequences::
- Simpler setup (shared secret).
- The verification component (webapp-backend) also needs the shared secret, increasing impact if it leaks (trade-off accepted).

IMPORTANT: Status: PROPOSED 

=== ADR-007: Secrets/config injection mechanism

Context::
- Secrets must not be stored in git.
- We need a simple approach for local dev and CI.

Decision::
- Use environment variables for secrets/config.
- In local dev, load them via dotenv (.env not committed).

Consequences::
- Easy to use with Docker Compose and CI secret stores.
- Requires discipline to avoid printing/leaking env values in logs.

IMPORTANT: Status: PROPOSED 

=== ADR-008: Error response envelope

Context::
- Multiple services and clients need consistent error handling.

Decision::
- Standardize JSON error responses using:
  - errorCode
  - message
  - requestId

Consequences::
- Easier frontend/BFF error mapping and debugging.
- Requires keeping error codes stable over time.

IMPORTANT: Status: PROPOSED 

=== ADR-009: BFF -> Game Service Timeouts

Context::
- Bot move computation and network calls can be slow or fail.
- The BFF must remain responsive.

Decision::
- Apply timeouts to BFF -> game service requests.
- Allow strictly bounded retries only for safe, idempotent operations.

Consequences::
- Prevents hanging requests and improves UX.
- Retries can increase load during outages; keep limits conservative and configurable.

IMPORTANT: Status: PROPOSED 

=== ADR-010: User persistence and minimal user entity

Context::
- users should persist users in a database.
- We likely need credentials, not only usernames.

Decision::
- users will persist user accounts.
- Minimal entity includes credentials (exact schema TBD, e.g., username + password hash + id).

Consequences::
- Requires choosing DB technology and defining credential storage rules (hashing, etc.).
- Enables real authentication flows.

IMPORTANT: Status: PROPOSED 

=== ADR-011: ADR-011: Client/Server entrypoint and API boundaries

Context::
- The system follows a client/server architecture: clients (web SPA and external bots) communicate with a server over HTTP.
- We want a single public entrypoint and serve the SPA from root path.
- The assignment requires a public API for bots and user management (register/login/history).

Decision::
- Public entrypoint routes:
  - / -> client (frontend SPA)
  - /api/public/v1/... -> server public API (game actions for clients/bots, e.g., play/choose-move using YEN/JSON)
  - /api/server/v1/... -> server internal API (user/auth/profile/history; not intended as bot API)

Consequences::
- Clear separation between UI and API.
- Enables a reverse proxy setup with path-based routing.

IMPORTANT: Status: PROPOSED 

=== ADR-012: Reverse proxy for path-based routing (Nginx)

Context::
- We need to route / to the frontend and /api/v1/... to the BFF behind a single port.
- An API gateway is considered overkill for this project.

Decision::
- Use an Nginx reverse proxy for path-based routing.

Consequences::
- One public port with simple routing rules (e.g., `location` + `proxy_pass`). [web:187]
- Adds an extra component to configure and maintain (but still lightweight).

IMPORTANT: Status: PROPOSED 
